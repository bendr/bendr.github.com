<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Bender; or, a declarative, dynamic framework for Web application
    graphical user interfaces</title>
<link rel="stylesheet" href="../../bender.css">
<link rel="stylesheet" href="reference.css">
<link rel="stylesheet" href="../font-awesome.css">
</head>
<body>
<div class="under-dev"><div class="icon-wrench">  Under Development</div></div>
<a href="#" id="to_top"><div class="icon-arrow-up to_top_icon"></div></a><div class="content">
<div class="tiles quarter">
<div class="pink-bg" id="logo"><a href="../../index.html"></a></div>
<div class="text blue-bg"><div>
<h2>Elements</h2>
<ul class="inline-list">
<li><a href="#attribute">attribute</a></li>
<li><a href="#component">component</a></li>
<li><a href="#content">content</a></li>
<li><a href="#foreign-view-content"><em>foreign view content</em></a></li>
<li><a href="#get">get</a></li>
<li><a href="#link">link</a></li>
<li><a href="#property">property</a></li>
<li><a href="#set">set</a></li>
<li><a href="#text">text</a></li>
<li><a href="#view">view</a></li>
<li><a href="#watch">watch</a></li>
</ul>
</div></div>
<div class="text green-bg"><div>
<h2>Attributes</h2>
<ul class="inline-list">
<li><a href="#as">as</a></li>
<li><a href="#attr">attr</a></li>
<li><a href="#component-ref">component</a></li>
<li><a href="#delegate">delegate</a></li>
<li><a href="#dom-event">dom-event</a></li>
<li><a href="#event">event</a></li>
<li><a href="#href-component">href</a></li>
<li><a href="#href-link">href</a></li>
<li><a href="#id">id</a></li>
<li><a href="#attribute-name">name</a></li>
<li><a href="#property-name">name</a></li>
<li><a href="#ns">ns</a></li>
<li><a href="#property-ref">property</a></li>
<li><a href="#rel">rel</a></li>
<li><a href="#view-ref">view</a></li>
<li><a href="#value">value</a></li>
</ul>
</div></div>
<div class="text peach-bg"><div><h2><a href="bender.rng">Relax NG grammar</a></h2></div></div>
<div class="text gray-bg"><div><p>Copyright © 2011-2013, <a href="http://www.igel.co.jp">IGEL
              Co., Ltd.</a></p></div></div>
</div>
<div class="description threefourth"><div>
<header><hgroup><h1>Bender; or, a declarative, dynamic framework for Web application
    graphical user interfaces</h1>
<h2>XML grammar and Javascript API specification</h2></hgroup><p class="creator">Julien Quint, <a href="http://igel.co.jp/">IGEL Co.,
      Ltd.</a></p>
<p class="date">Version 0.8, 19 February 2013</p></header><nav id="toc"><h2>Table of contents</h2>
<ul>
<li><a href="#idp353504">1 Introduction</a></li>
<li>
<a href="#idp360800">2 Bender runtimes</a><ul>
<li><a href="#idp361712">2.1 DOM-based and other runtimes</a></li>
<li><a href="#idp374464">2.2 Rendering a Bender component in a host document</a></li>
<li><a href="#idp377440">2.3 Runtime update sequences</a></li>
</ul>
</li>
<li>
<a href="#idp410000">3 Document structure</a><ul>
<li><a href="#idp411808">3.1 The Bender namespace URI</a></li>
<li><a href="#idp415136">3.2 Document element</a></li>
<li><a href="#idp417136">3.3 Relax NG grammar and terminology</a></li>
</ul>
</li>
<li>
<a href="#idp431504">4 Introduction to the Bender Javascript API</a><ul>
<li><a href="#idp433600">4.1 The Bender runtime</a></li>
<li><a href="#idp439824">4.2 The Bender context</a></li>
<li><a href="#idp459872">4.3 The Bender DOM</a></li>
</ul>
</li>
<li>
<a href="#idp467872">5 Events</a><ul>
<li><a href="#idp468784">5.1 Bender events</a></li>
<li><a href="#event-ready">5.2 The <code>@ready</code> event</a></li>
<li><a href="#event-rendered">5.3 The <code>@rendered</code> event</a></li>
<li><a href="#event-updated">5.4 The <code>@updated</code> event</a></li>
</ul>
</li>
<li>
<a href="#idp487920">6 Elements</a><ul>
<li><a href="#attribute">6.1 The <code>attribute</code> element</a></li>
<li>
<a href="#component">6.2 The <code>component</code> element</a><ul>
<li><a href="#idp535232">6.2.1 The component as a container</a></li>
<li><a href="#idp540992">6.2.2 Component prototype and inheritance</a></li>
<li><a href="#idp545744">6.2.3 Component view and rendering</a></li>
<li><a href="#idp553568">6.2.4 Component properties and watches</a></li>
<li><a href="#idp570048">6.2.5 Component delegates</a></li>
</ul>
</li>
<li><a href="#content">6.3 The <code>content</code> element</a></li>
<li><a href="#foreign-view-content">6.4 Foreign view content</a></li>
<li>
<a href="#get">6.5 The <code>get</code> element</a><ul>
<li><a href="#idp643328">6.5.1 Watch inputs</a></li>
<li><a href="#idp648288">6.5.2 Bender events</a></li>
<li><a href="#idp649072">6.5.3 DOM events</a></li>
<li><a href="#idp649856">6.5.4 Properties</a></li>
</ul>
</li>
<li><a href="#link">6.6 The <code>link</code> element</a></li>
<li><a href="#property">6.7 The <code>property</code> element</a></li>
<li><a href="#set">6.8 The <code>set</code> element</a></li>
<li><a href="#text">6.9 The <code>text</code> element</a></li>
<li><a href="#view">6.10 The <code>view</code> element</a></li>
<li><a href="#watch">6.11 The <code>watch</code> element</a></li>
</ul>
</li>
<li>
<a href="#idp724416">7 Attributes</a><ul>
<li><a href="#as">7.1 The <code>as</code> attribute</a></li>
<li><a href="#attr">7.2 The <code>attr</code> attribute</a></li>
<li><a href="#component-ref">7.3 The <code>component</code> attribute</a></li>
<li><a href="#delegate">7.4 The <code>delegate</code> attribute</a></li>
<li><a href="#dom-event">7.5 The <code>dom-event</code> attribute</a></li>
<li><a href="#event">7.6 The <code>event</code> attribute</a></li>
<li><a href="#href-component">7.7 The <code>href</code> attribute</a></li>
<li><a href="#href-link">7.8 The <code>href</code> attribute</a></li>
<li><a href="#id">7.9 The <code>id</code> attribute</a></li>
<li><a href="#attribute-name">7.10 The <code>name</code> attribute</a></li>
<li><a href="#property-name">7.11 The <code>name</code> attribute</a></li>
<li><a href="#ns">7.12 The <code>ns</code> attribute</a></li>
<li><a href="#property-ref">7.13 The <code>property</code> attribute</a></li>
<li><a href="#rel">7.14 The <code>rel</code> attribute</a></li>
<li><a href="#view-ref">7.15 The <code>view</code> attribute</a></li>
<li><a href="#value">7.16 The <code>value</code> attribute</a></li>
</ul>
</li>
</ul></nav><section id="idp353504"><h2>1 Introduction</h2>
<section class="longdesc">
      <p>
        This specification defines the XML syntax, Javascript API, and
        informal semantics of the Bender framework.
        Bender is an experimental framework for client-side Web application
        authoring.
        Bender is <strong>declarative</strong>, building on existing
        declarative languages such as <a href="http://www.w3.org/html/wg/drafts/html/master/Overview.html">HTML</a>,
        <a href="http://www.w3.org/TR/SVG/">SVG</a> and
        <a href="http://www.w3.org/TR/CSS2/">CSS</a> to describe the
        <strong>layout</strong>, <strong>structure</strong> as well as
        the <strong>logic</strong> of the application.
        A Bender application <em>description</em> can be serialized to XML
        following the syntax described in this specification.
        Such a description can then be <em>rendered</em> by a
        <em>runtime</em> hosted by an application such as a Web browser.
        To the end user, a Bender application looks and behaves just like any
        other Web application.
      </p>
    </section></section><section id="idp360800"><h2>2 Bender runtimes</h2>
<section class="longdesc">
      <section id="idp361712"><h3>2.1 DOM-based and other runtimes</h3>
<p>
          There can be different types of runtimes for Bender, such as
          <em>DOM-based</em> runtimes, <em>static</em> runtimes or
          <em>procedural</em> runtimes.
          This specification covers only the first case in detail, as it is
          implemented by the reference runtime.
          Later versions may cover other types of runtimes in more detail.
        </p>
<p>
          A <strong>DOM-based</strong> runtime is a runtime that uses the
          <a href="http://www.w3.org/TR/2011/WD-domcore-20110531/">DOM
            tree of a document</a>, called the <strong>host
            document</strong>, as the target of its output.
          Rendering is done by adding DOM nodes (elements, attributes, and text
          nodes) to the host tree.
          The host tree itself is rendered by a <strong>host
            application</strong>, most likely a Web browser.
          The reference runtime follows this model.
          It is run inside a browser, using a HTML5 host document and Javascript
          to render components.
        </p>
<p>
          The Bender reference implementation also allows authors to write
          custom runtimes.
          It is possible for instance to duplicate the functionality of the
          reference runtime but with an SVG host document as opposed to an
          HTML5 host document.
          It is also possible to insert one or more Bender components into a
          document at arbitrary locations using scripting and the Bender
          Javascript library.
        </p>
<p>
          A <strong>static</strong> runtime is not really a runtime, but
          more of a translator, or compiler (whereas a DOM-based or procedural
          runtime is more similar to an interpreter.)
          In a static runtime, the Bender application is rendered into a static
          output, which in the context of Bender means that the result output
          has lost its ability to refer to its original definition (just like a
          compiler usually discards the source of the program to produce its
          output.)
          It is possible to go further and imagine at least two kinds of static
          runtimes:
        </p>
<ol>
          <li>
            the <em>compiler</em>, which translates a Bender description
            into a form that can be run directly.
            For instance, a Bender compiler would produce a “cooked” HTML5
            document with Javascript code that looks just like a regular Web
            application and can run directly into a regular browser without
            requiring any additional runtime support;
          </li>
          <li>
            the <em>printer</em>, which outputs a static document, such as
            an image or a PDF file, of the state of the application as
            described.
            (In the future, it is expected that Bender will support some kind of
            persistence to make this feature more useful.)
          </li>
        </ol>
<p>
          Lastly, a <strong>procedural</strong> runtime is a runtime that
          renders a Bender document in a procedural, rather than declarative,
          fashion.
          While a DOM-based runtime is lazy and simply outputs DOM nodes,
          leaving the host application in charge of rendering the result, a
          procedural runtime takes full control and actively manages all
          aspects of the output.
          An hypothetic procedural runtime could render Bender applications in
          a HTML5 canvas element, using a 2D context, or WebGL
          for a 3D rendering.
        </p></section>
      <section id="idp374464"><h3>2.2 Rendering a Bender component in a host document</h3>
<p>
          In a DOM-based runtime, a component is rendered by creating a document
          fragment, and inserting it in the tree of the host document.
          The <strong>target</strong> of a component is the insertion point
          for such a fragment.
          It is defined by a <em>parent element</em> and an optional
          <em>reference node</em>, which must be a child of the parent
          element if present.
          The document fragment is inserted as a child of the parent element,
          before the reference node if it is defined, or as the last child
          otherwise.
        </p></section>
      <section id="idp377440"><h3>2.3 Runtime update sequences</h3>
<p>
          Once the runtime has started, <em>requests</em> can be made to
          perform updates.
          The runtime maintains a queue of requests so that they can be
          prioritized (<em>e.g.</em>, as much of a component should be
          constructed before it is rendered.)
          This request mechanism is transparent to the author: no explicit
          “request” needs to be made to the runtime, but simple calls to the
          API, such as creating an element, setting a property, &amp;c.
        </p>
<p>
          It is however useful to describe the handling of requests to better
          define the semantics of Bender.
          A batch of requests is processed in an <em>update sequence</em>.
          While an update sequence is being executed, all new requests are
          queued and will be processed in the next sequence (with the
          exception of the internal update sequence as describe below.)
        </p>
<ol>
          <li>
            Create a request queue <em>Q</em>.
          </li>
          <li>
            When a request is made, add it to <em>Q</em> and set a timer
            <em>T</em>.
            This specification leaves the specifics of timer expiry to
            implementations.
            For instance, the reference Javascript implementation is
            single-threaded and simply sets a zero-length timer so that
            request processing will begin when the current thread is done
            running.
          </li>
          <li>
            Additional requests made before <em>T</em> expires are added
            to <em>Q</em>.
          </li>
          <li>
            When <em>T</em> expires, create a new request queue
            <em>Q’</em>.
            Unless otherwise noted, new requests are now added to
            <em>Q’</em>, setting a timer <em>T’</em>, which must not
            expire before all requests from <em>Q</em> have been
            processed.
          </li>
          <li>
            Process requests from <em>Q</em>.
            <ol style="list-style-type: lower-roman">
              <li>
                Process all <em>explicit update</em> requests,
                <em>i.e.</em>, requests made explicitely through the
                Javascript API (see the explicit updates sequence below.)
              </li>
              <li>
                Process all <em>rendering update</em> requests,
                <em>i.e.</em>, render components that have been created or
                added in the previous step (see the rendering sequence
                below.)
              </li>
              <li>
                Process all <em>implicit update</em> requests,
                <em>i.e.</em>, requests resulting from changes made in the
                previous steps and from component watches (see the implicit
                updates sequence below.)
              </li>
            </ol>
          </li>
          <li>
            Reset all <a class="elem" href="#watch">watch</a> inputs that were activated during
            the processing of the requests to inactive.
          </li>
          <li>
            All requests from <em>Q</em> have been processed, so
            <em>Q</em> is replaced with <em>Q’</em>.
            <ol style="list-style-type: lower-roman">
              <li>
                If <em>T’</em> was not set, go back to step 2.
              </li>
              <li>
                If <em>T’</em> was set (<em>i.e.</em>, <em>Q’</em>
                is not empty), replace the expired <em>T</em> with
                <em>T’</em>, which is now allowed to expire.
                Then, go back to step 3.
              </li>
            </ol>
          </li>
        </ol>
<section id="idp400080"><h4>2.3.1 The explicit updates sequence</h4>
<p>
            An <strong>explicit update</strong> is a made through the
            Javascript API.
            For instance, creating components programmatically and adding them
            to a context generate explicit update requests.
            Setting a property on a component through Javascript is another
            example of explicit update request.
          </p>
<p>
            An explicit update will most likely create new update requests as
            a side-effect.
            These requests are added to the queue <em>Q</em> so that they
            are processed in the same batch of update sequences.
            Adding a new component will create a rendering update, so that the
            component is rendered as soon as possible.
            Modifying the DOM tree or setting a property of a rendered
            component will generate implicit update requests.
          </p></section><section id="idp403328"><h4>2.3.2 The rendering updates sequence</h4>
<p>
            Components that have not been rendered yet are now rendered,
            using the current DOM content for the component as set through
            the previously processed explicit updates.
            This generates a <a class="event" href="#event-rendered">@rendered</a> event which may
            cause implicit updates.
          </p></section><section id="idp405312"><h4>2.3.3 The implicit update sequence</h4>
<p>
            An <strong>implicit update</strong> is an update that needs to be
            made in order to maintain the consistency of the running
            application.
            As the name implies, these updates are not made explicitely by the
            author, but by the runtime itself as a side-effect of a previous
            update, or as result of a watch being activated.
          </p>
<p>
            An implicit update may modify the rendering of a component.
            This differs from a rendering update in that an
            <a class="event" href="#event-updated">@updated</a> event is generated rather than a
            <a class="event" href="#event-rendered">@rendered</a> event.
            Because a component is rendered only once, but see multiple
            updates even in the same update sequence, <a class="event" href="#event-updated">@updated</a> events are consolidated and sent only once per
            sequence.
          </p></section></section>
    </section></section><section id="idp410000"><h2>3 Document structure</h2>
<section class="longdesc">
      <section id="idp411808"><h3>3.1 The Bender namespace URI</h3>
<p>
          All Bender elements are in the <span class="nsuri">http://bender.igel.co.jp</span> namespace URI.
        </p>
<p>
          Some Bender elements can have <em>foreign content</em>, that is
          elements belonging to namespaces other than Bender.
          It is important to correctly specify the namespace of these foreign
          elements, for instance using namespace prefixes.
          The XHTML namespace URI
          <span class="nsuri">http://www.w3.org/1999/xhtml</span> is used to
          identify HTML content.
        </p></section>
      <section id="idp415136"><h3>3.2 Document element</h3>
<p>A Bender XML document always describes a component; therefore, the
          document element is a <a class="elem" href="#component">component</a> element. Since almost
          everything in Bender is a component, a document may define a single
          reusable widget-like component, a complete application, or a library
          of components.</p></section>
      <section id="idp417136"><h3>3.3 Relax NG grammar and terminology</h3>
<p>
          This specification includes the complete <a href="bender.rng">Relax
            NG grammar</a> for checking the validity of Bender XML documents.
          The specification of every element and attribute includes information
          extracted from this grammar, describing in which context it may
          appear, and what contents it may have.
          Attributes may occur once, unless otherwise noted, and in any order.
          Elements must occur once, and in the order specified, unless otherwise
          noted.
          The following terms from Relax NG are used:
        </p>
<ul>
          <li>
            <strong>choice</strong>: only one of the possible contents may
            occur;
          </li>
          <li>
            <strong>data</strong>: a data value that matches the given type.
          </li>
          <li>
            <strong>group</strong>: all of the contents must occur;
          </li>
          <li>
            <strong>interleaving</strong>: the children of the element may
            occur in any order;
          </li>
          <li>
            <strong>mixed</strong>: the element has <em>mixed</em>
            content, which means that its children may occur in any order, and
            it may also contain text;
          </li>
          <li>
            <strong>optional</strong>: the element or attribute may not
            occur (<em>i.e.</em>, it may occur once or not at all);
          </li>
          <li>
            <strong>one or more</strong>: the element may occur any number
            of times, but at least once;
          </li>
          <li>
            <strong>text</strong>: plain text.
            This is not the same as the <a class="elem" href="#text">text</a> element;
          </li>
          <li>
            <strong>value</strong>: a text string that matches the given
            value exactly, with the possibily of leading and trailing
            whitespace;
          </li>
          <li>
            <strong>zero or more</strong>: the element may occur any number
            of the times, including not at all.
          </li>
        </ul>
<p>
          Please refer to the <a href="http://relaxng.org/tutorial-20011203.html">Relax NG
            tutorial</a> for an introduction to and more information about
          Relax NG.
        </p></section>
    </section></section><section id="idp431504"><h2>4 Introduction to the Bender Javascript API</h2>
<section class="longdesc">
      <p>
        The Javascript API for Bender is described using a syntax similar to
        <a href="http://www.w3.org/TR/WebIDL/">Web IDL</a>.
      </p>
      <section id="idp433600"><h3>4.1 The Bender runtime</h3>
<p>
          In the reference implementation, the bender runtime is accessible
          through the <span class="keyword">window.bender</span> object.
        </p>
<section><p><em>Javascript API</em></p>
<pre class="api">Interface <span class="idl-interface-def" id="interface-DOMRuntime">DOMRuntime</span> {
  Context <span class="idl-method-def" id="idl-DOMRuntime-create_context">create_context</span>(Document host?);
}</pre>
<p>
            This specification focuses on DOM-based runtimes.
            In the future, different runtime interfaces may be added.
          </p>
<p>
              <a href="#idl-DOMRuntime-create_context" class="idl-method">create_context</a> creates a new <a href="#interface-Context" class="idl-interface">Context</a>.
              The context is created is created in the <code>host</code>
              document, which defaults to the document in which the runtime is
              executed.
            </p></section></section>
      <section id="idp439824"><h3>4.2 The Bender context</h3>
<p>
          The Bender <strong>context</strong> is the entity in charge of
          managing the execution environment of Bender components.
          It provides basic functionality for component loading and rendering,
          as well as convenience methods to support the runtime and Bender
          applications.
          It also runs the different runtime update sequences as described
          below.
        </p>
<section><p><em>Javascript API</em></p>
<pre class="api">Interface <span class="idl-interface-def" id="interface-Context">Context</span> {
  readonly attribute Document <span class="idl-attribute-def" id="idl-attribute-document">document</span>;
  void <span class="idl-method-def" id="idl-Context-render_component">render_component</span>(BenderComponentElement component, Element parent, Node ref?);
  Element <span class="idl-method-def" id="idl-Context-$">$</span>(string name, dictionary&lt;string, any&gt; attrs?, ...);
}</pre>
<p>
              <a href="#idl-attribute-document" class="idl-attribute">document</a> is the host document for the context, as set
              by <a href="#idl-DOMRuntime-create_context" class="idl-method">create_context</a>.
            </p>
<p>
              <a href="#idl-Context-render_component" class="idl-method">render_component</a> adds the rendered nodes of
              <code>component</code> to the element <code>parent</code>.
              The parent element must be an element of the host document.
              If the <code>reference</code> node is present, it must be a
              child of <code>parent</code>.
              The rendered nodes are added to <code>parent</code> before
              <code>reference</code>, or as the last children of
              <code>parent</code> if <code>reference</code> is not
              specified.
            </p>
<p>
              <a href="#idl-Context-%24" class="idl-method">$</a> is a utility method to create new elements in the
              host document.
              <code>name</code> is the qualified name of the element to
              create; by default, the Bender namespace is implied.
              Know prefixes are implementation dependent.
              <code>attrs</code> is an optional dictionary of attributes,
              mapping attribute names for the new element to their value.
              Attributes are created with values as-is, except when the value
              is <span class="keyword">false</span> (<em>i.e.</em>, with the
              boolean type, not the empty string or zero),
              <span class="keyword">null</span> or <span class="keyword">undefined</span>,
              then no attribute is created for this value.
            </p>
<p>
              There can then be any number of additional parameters, which are
              all interpreted as contents of the new element. These can be
              DOM nodes, text strings (for which a new text node is created),
              or arrays, the contents of which are added as contents of the
              new element.
            </p></section></section>
      <section id="idp459872"><h3>4.3 The Bender DOM</h3>
<p>
          The Bender DOM extends the host DOM by providing additional attributes
          and methods to Bender elements.
          Moreover, regular DOM methods of Bender nodes are overloaded so that
          <em>mutations</em> of the DOM tree of a Bender component
          (<em>i.e.</em>, adding, removing or modifying attributes, child
          nodes and text content) are mirrored in the output by the runtime.
        </p>
<p>
          However, note that <em>properties</em> are not overloaded, so that
          setting the <code>textContent</code> or <code>nodeValue</code>
          of an element is not mirrored.
          Elements that can have text content provide a
          <code>set_textContent</code> that can be used instead.
        </p>
<section><p><em>Javascript API</em></p>
<pre class="api">Interface <span class="idl-interface-def" id="interface-BenderElement">BenderElement</span> : <a href="#interface-Element">Element</a> {
  attribute Context <span class="idl-attribute-def" id="idl-attribute-context">context</span>;
}</pre>
<p>
            <a href="#interface-BenderElement" class="idl-interface">BenderElement</a> is the base interface for all Bender elements
            defined below.
          </p>
<p>
              <a href="#idl-attribute-context" class="idl-attribute">context</a> points to the context in which this element
              was created.
            </p></section></section>
    </section></section><section id="idp467872"><h2>5 Events</h2>
<section class="longdesc">
      <section id="idp468784"><h3>5.1 Bender events</h3>
<p>
          Bender <strong>events</strong> are Bender-specific events similar
          to DOM events.
          Components can send and received events to and from each other through
          watches.
          A small number of predefined events are described below, and
          application authors may introduce their own custom events to manage
          inter-component communication inside their application.
        </p>
<p>
          Bender events may also be sent and received programmatically.
          This is actually <a href="/test/flexo.html?grep=Custom%20Events">handled by the Flexo
            library</a> through the
          <span class="keyword">flexo.listen()</span>,
          <span class="keyword">flexo.listen_once()</span>,
          <span class="keyword">flexo.notify()</span>, and
          <span class="keyword">flexo.unlisten()</span> functions.
        </p>
<section><p><em>Javascript API</em></p>
<pre class="api">Interface <span class="idl-interface-def" id="interface-BenderEvent">BenderEvent</span> {
  attribute Object <span class="idl-attribute-def" id="idl-attribute-source">source</span>;
  attribute string <span class="idl-attribute-def" id="idl-attribute-type">type</span>;
}</pre>
<p>
            An event notification is a simple Javascript object that can contain
            any number of properties as its arguments. There are however two
            properties that all events share as described below.
          </p>
<p>
              <a href="#idl-attribute-source" class="idl-attribute">source</a> is the Javascript object that generated the
              event.
            </p>
<p>
              <a href="#idl-attribute-type" class="idl-attribute">type</a> is the event type.
              Bender event types are by convention named starting with a
              <code>@</code> character, <em>e.g.</em>,
              <a href="#interface-@ready" class="idl-interface">@ready</a>, <a href="#interface-@rendered" class="idl-interface">@rendered</a>,
              <a href="#interface-@updated" class="idl-interface">@updated</a>, &amp;c.
            </p></section></section>
      <section id="event-ready"><h3>5.2 The <code>@ready</code> event</h3>
<p>
          The <code>@ready</code> event is sent by a component just before
          it is rendered.
        </p></section>
      <section id="event-rendered"><h3>5.3 The <code>@rendered</code> event</h3>
<p>
          The <code>@ready</code> event is sent by a component just after
          it was rendered.
        </p></section>
      <section id="event-updated"><h3>5.4 The <code>@updated</code> event</h3>
<p>
          The <code>@updated</code> event is sent by components that have
          seen some updates of their properties and/or view during the last
          update sequence.
        </p></section>
    </section></section><section id="idp487920"><h2>6 Elements</h2>
<section id="attribute"><h3>6.1 The <code>attribute</code> element</h3>
<p class="desc">Output an attribute node on rendering.</p>
<section class="spec"><p>Child of:<ul><li><a href="#foreign-view-content"><em>foreign view content</em></a></li></ul></p>
<p>Content:<ul>
<li>optional 
          <a href="#id">id</a> attribute
        </li>
<li>
<a href="#attribute-name">name</a> attribute</li>
<li>optional 
          <a href="#ns">ns</a> attribute
        </li>
<li>choice of:<ul>
<li>
<a href="#value">value</a> attribute</li>
<li><em>text</em></li>
</ul>
</li>
</ul></p></section><section class="longdesc">
        <p>
          The purpose of the <a class="elem" href="#attribute">attribute</a> element, similarly to the <a class="elem" href="#text">text</a> element, is twofold.
          First, it provides a way to set attributes of rendered elements
          explicitly.
          Second, by giving an <a class="attr" href="#id">id</a> attribute to the <a class="elem" href="#attribute">attribute</a>
          element, it can become the target of a <a class="elem" href="#set">set</a> element.
        </p>
        <p>
          An <a class="elem" href="#attribute">attribute</a> element must have a <a class="attr" href="#attribute-name">name</a>
          attribute.
          This is the name of the attribute that will be set on the rendered
          element.
          An <a class="elem" href="#attribute">attribute</a> element may have a <a class="attr" href="#ns">ns</a> attribute.
          The value must be a namespace URI (not a prefix.)
          If this attribute is present, then the attribute name will be
          qualified with this namespace.
        </p>
        <p>
          An <a class="elem" href="#attribute">attribute</a> element must have either a <a class="attr" href="#attribute-name">name</a> attribute or (possibly empty) text content.
          This is the value for the rendered attribute.
        </p>
        <p>
          When the parent element is rendered, an attribute is added to this
          element.
          The local name (and possibly namespace URI) of the attribute are
          the values of the <a class="attr" href="#attribute-name">name</a> and <a class="attr" href="#ns">ns</a> of the element.
          The value of the attribute node is the same as the value of the
          element.
        </p>
      <section><p><em>Javascript API</em></p>
<pre class="api">Interface <span class="idl-interface-def" id="interface-BenderAttributeElement">BenderAttributeElement</span> : <a href="#interface-BenderElement">BenderElement</a> {
  attribute string <span class="idl-attribute-def" id="idl-attribute-name">name</span>;
  attribute string <span class="idl-attribute-def" id="idl-attribute-ns">ns</span>;
  attribute string <span class="idl-attribute-def" id="idl-attribute-value">value</span>;
  Node <span class="idl-method-def" id="idl-BenderAttributeElement-insertBefore">insertBefore</span>(Node child);
  void <span class="idl-method-def" id="idl-BenderAttributeElement-set_text_content">set_text_content</span>(string text);
}</pre>
<p>
            The <a href="#idl-attribute-name" class="idl-attribute">name</a> property of a <a href="#interface-BenderAttributeElement" class="idl-interface">BenderAttributeElement</a> reflects
            the value of the <a class="attr" href="#attribute-name">name</a> attribute of the
            element.
            It can be used to get or set the value of the attribute.
            When setting a new value, all rendered instances of the parent
            component and components that derive from it are updated.
          </p>
<p>
            The <a href="#idl-attribute-ns" class="idl-attribute">ns</a> property of a <a href="#interface-BenderAttributeElement" class="idl-interface">BenderAttributeElement</a> reflects
            the value of the <a class="attr" href="#ns">ns</a> attribute of the
            element.
            It can be used to get or set the value of the attribute.
            When setting a new value, all rendered instances of the parent
            component and components that derive from it are updated.
          </p>
<p>
            The <a href="#idl-attribute-value" class="idl-attribute">value</a> property of a <a href="#interface-BenderAttributeElement" class="idl-interface">BenderAttributeElement</a> reflects
            the value of the <a class="attr" href="#value">value</a> attribute of the element, or
            its text content, whichever is set.
            Getting the value of this property returns the value of the <a class="attr" href="#value">value</a> attribute if it is defined, or the text content of
            the element otherwise.
            Setting the value always sets the <a class="attr" href="#value">value</a> attribute
            and clears the text content of the element, if any.
            When setting a new value, all rendered instances of the parent
            component and components that derive from it are updated.
          </p>
<p>
            As <a class="elem" href="#attribute">attribute</a> can only have text content, <a href="#idl-BenderAttributeElement-insertBefore" class="idl-method">insertBefore</a> will only
            insert a text or CDATA node.
            When a new child node is inserted, the <a class="attr" href="#value">value</a>
            attribute is removed the <a class="elem" href="#attribute">attribute</a> element.
            All rendered instances of the parent component and components that
            derive from it are updated.
          </p>
<p>
            <a href="#idl-BenderAttributeElement-set_text_content" class="idl-method">set_text_content</a> updates the text content of the <a class="elem" href="#attribute">attribute</a> element.
            When updating the text content, the <a class="attr" href="#value">value</a> attribute
            is removed from the <a class="elem" href="#attribute">attribute</a> element.
            All rendered instances of the parent component and components that
            derive from it are updated.
          </p></section></section></section><section id="component"><h3>6.2 The <code>component</code> element</h3>
<p class="desc">Define a Bender component.</p>
<section class="spec"><p>Child of:<ul>
<li><a href="#component">component</a></li>
<li><a href="#content">content</a></li>
<li><a href="#foreign-view-content"><em>foreign view content</em></a></li>
<li><a href="#view">view</a></li>
</ul></p>
<p>Content:<ul>
<li>optional 
          <a href="#delegate">delegate</a> attribute
        </li>
<li>optional 
          <a href="#href-component">href</a> attribute
        </li>
<li>optional 
          <a href="#id">id</a> attribute
        </li>
<li>zero or more <em>other</em> attributes</li>
<li>interleaving of:<ul>
<li>zero or more <a href="#component">component</a> elements</li>
<li>zero or more <a href="#link">link</a> elements</li>
<li>zero or more <a href="#property">property</a> elements</li>
<li>optional 
            <a href="#view">view</a> element
          </li>
<li>zero or more <a href="#watch">watch</a> elements</li>
</ul>
</li>
</ul></p></section><section class="longdesc">
        <p>The <strong>component</strong> is the core element in Bender.
          It also plays a dual role: at the <strong>document</strong> level,
          it may be used as a <strong>container</strong> for other
          components; at the <strong>runtime</strong> level, it is a unit of
          functionality that is described by its <em>prototype</em>,
          <em>view</em>, <em>properties</em>, and
          <em>watches</em>.</p>
        <section id="idp535232"><h4>6.2.1 The component as a container</h4>
<p>Components are identified by their URI. This specification only
            describe the identification of a component by its URL; that is, the
            URL of its document with the addition of the value of its <a class="attr" href="#id">id</a> attribute as a fragment identifier. A component that
            is the document element may be identified by the URL of its document
            only. A component that is not the document element and has no
            <a class="attr" href="#id">id</a> cannot be identified using an URL.</p>
<p>When a <a class="elem" href="#component">component</a> element appears as a child of
            another <a class="elem" href="#component">component</a> element, it does not modify the
            definition of its parent component in any way. It is a completely
            independent component, with its own prototype, view, properties,
            and watches. This allows to group components with related
            functionality inside a single document, while making each component
            available outside thanks to its URI.</p>
<p class="future">Future specifications of Bender will describe a
            scheme for identifying components with URIs that do not depend on
            the specific location of documents, <em>e.g.</em>, using search
            paths for known component libraries.</p></section>
        <section id="idp540992"><h4>6.2.2 Component prototype and inheritance</h4>
<p>Bender implements <strong>inheritance</strong> through
            <em>prototypes</em> rather than classes, following Javascript in
            this respect. A component may have another component as its
            <strong>prototype</strong>, which is identified by the <a class="attr" href="#href-component">href</a> attribute of the component element.</p>
<p>
            The prototype of a component may have a prototype, which in turn may
            have a prototype.
            The <em>prototype chain</em> can be of arbitrary length and must
            end in a component that has no prototype.
            It cannot contain a cycle; <em>i.e.</em>, a component cannot
            appear more than once in the prototype chain.
          </p></section>
        <section id="idp545744"><h4>6.2.3 Component view and rendering</h4>
<p>
            The <a class="elem" href="#view">view</a> element defines the
            <strong>rendering</strong> of the component.
            The view is optional, and a component with no view can still be
            instantiated (<em>i.e.</em> it can have properties,
            send event notifications, &amp;c.)
            A component cannot have multiple <a class="elem" href="#view">view</a> children.
          </p>
<p>
            A component inherits its prototype’s view, if any.
            It can also <em>extend</em> that prototype’s view by defining
            additional <em>content</em>.
          </p>
<p>
            The <strong>view</strong> of a component is defined to be the
            view of its prototype, if it has a prototype and that prototype has
            a view; otherwise, it is its child <a class="elem" href="#view">view</a> element.
            When these two conditions are met, the child <a class="elem" href="#view">view</a>
            element of the component will replace the descendant <a class="elem" href="#content">content</a> element its prototype’s view to extend it.
            If neither condition is met, then the component has no view.
          </p></section>
        <section id="idp553568"><h4>6.2.4 Component properties and watches</h4>
<p>
            A component can be parametrized through the use of
            <em>properties</em>.
            Properties are named and have a value which can then be rendered
            or used to control the behavior of the component using
            <em>watches</em>.
          </p>
<p>
            A <strong>property</strong> is described by the <a class="elem" href="#property">property</a> element.
            A component may have any number of child <a class="elem" href="#property">property</a>
            elements.
            All child <a class="elem" href="#property">property</a> elements of a component must
            have a different name.
            The order of definition of properties is not significant.
          </p>
<p>
            A component inherits the properties of its prototype.
            A component’s <strong>own properties</strong> are the properties
            defined by its child <a class="elem" href="#property">property</a> elements, and those
            for which a value has been set on that component.
          </p>
<p>
            Property values may be set for a component through different means:
          </p>
<ul>
            <li>
              by setting the value of a child <a class="elem" href="#property">property</a> element:
              this is the <em>default value</em>;
            </li>
            <li>
              by setting the value of an attribute on the
              <a class="elem" href="#"></a> element that has the name of the
              property (provided that this name is not
              <span class="keyword">delegate</span>, <span class="keyword">href</span>, or
              <span class="keyword">id</span>, and that it is syntactically correct in
              XML): this is the <em>initial value</em>;
            </li>
            <li>
              with a <a class="elem" href="#watch">watch</a>: the <em>current value</em> is
              set on the object;
            </li>
            <li>
              with the Javascript API, by manipulating the current value on the
              component object directly.
            </li>
          </ul>
<p>
            A <strong>watch</strong> is a device allowing the the mapping of
            certain <em>inputs</em>, namely events from components, DOM
            events from rendered elements, and changes in property values from
            components, to <em>outputs</em>, namely sending event
            notifications, setting attributes of rendered elements, and setting
            property values.
            A watch is described by the <a class="elem" href="#watch">watch</a> element.
            A component may have have any number of child <a class="elem" href="#watch">watch</a>
            elements.
            The order of definition of watches is not significant.
          </p></section>
        <section id="idp570048"><h4>6.2.5 Component delegates</h4>
<p>
            The <em>delegate</em> of a component is an object that extends
            the Javascript API of the component.
            The delegate can override methods of the component API and provide
            new functionality through additional code and data.
          </p>
<p>
            The <strong>delegate</strong> of a component is specified by
            the <a class="attr" href="#delegate">delegate</a> attribute.
          </p></section>
      <section><p><em>Javascript API</em></p>
<pre class="api">Interface <span class="idl-interface-def" id="interface-BenderComponentElement">BenderComponentElement</span> : <a href="#interface-BenderElement">BenderElement</a> {
  attribute ComponentDelegate? <span class="idl-attribute-def" id="idl-attribute-delegate">delegate</span>;
  attribute Array&lt;BenderComponentElement&gt; <span class="idl-attribute-def" id="idl-attribute-derived">derived</span>;
  attribute string? <span class="idl-attribute-def" id="idl-attribute-href">href</span>;
  readonly attribute Dictionary&lt;string, any&gt; <span class="idl-attribute-def" id="idl-attribute-initials">initials</span>;
  readonly attribute Dictionary&lt;string, BenderPropertyElement&gt; <span class="idl-attribute-def" id="idl-attribute-properties">properties</span>;
  attribute BenderComponentElement? <span class="idl-attribute-def" id="idl-attribute-prototype">prototype</span>;
  readonly attribute Dictionary&lt;string, any&gt; <span class="idl-attribute-def" id="idl-attribute-values">values</span>;
  attribute BenderViewElement <span class="idl-attribute-def" id="idl-attribute-view">view</span>;
}</pre>
<p>
            <a href="#idl-attribute-delegate" class="idl-attribute">delegate</a> is the actual delegate object of the component,
            as obtained from the <attribute name="delegate"></attribute> attribute.
            A new delegate can be set through this property.
            Although this attribute is either undefined or has <a href="#interface-ComponentDelegate" class="idl-interface">ComponentDelegate</a> value, it can be set to either a
            <a href="#interface-ComponentDelegate" class="idl-interface">ComponentDelegate</a> or
            <code>string</code> value.
            In the case of a <code>string</code> value, the string is
            first evaluated just like a <attribute name="delegate"></attribute>
            attribute value; if this resolves to an object then the delegate
            is set to that object.
            When a delegate is set, the previous delegate, if any, is unset by
            calling its <a href="#idl-idl-ComponentDelegate-unset" class="idl-method">ComponentDelegate-unset</a> method.
          </p>
<p>
            <a href="#idl-attribute-initials" class="idl-attribute">initials</a> is a live dictionary of the <strong>initial
              values</strong> for the component’s properties.
            Property names are mapped to initial values.
            If the component element has an attribute with the same name as
            a property, then the value of this attribute is the initial value
            of the property for this component.
            The <a href="#idl-attribute-initials" class="idl-attribute">initials</a> dictionary maps names of properties that
            have no initial value to <span class="keyword">null</span>, and strings
            that do not map to a property of a component to
            <span class="keyword">undefined</span>.
            Setting a new initial value for an existing property name will
            set the corresponding attribute value.
            Setting a null value will delete the corresponding attribute.
            In both cases, the current value is set to the new initial value.
            Setting a new initial value for a string that is not the name of a
            property has no effect.
          </p>
<p>
            <a href="#idl-attribute-prototype" class="idl-attribute">prototype</a> is the prototype component of this component, if
            any.
          </p></section><section><pre class="api">Interface <span class="idl-interface-def" id="interface-ComponentDelegate">ComponentDelegate</span> {
  void <span class="idl-method-def" id="idl-ComponentDelegate-did_render">did_render</span>(BenderComponentElement component);
  void <span class="idl-method-def" id="idl-ComponentDelegate-set">set</span>(BenderComponentElement component);
  void <span class="idl-method-def" id="idl-ComponentDelegate-unset">unset</span>(BenderComponentElement component);
  void <span class="idl-method-def" id="idl-ComponentDelegate-will_render">will_render</span>(BenderComponentElement component);
}</pre>
<p>
          Delegate objects for Bender components should implement one or more of
          the methods of the <a href="#interface-ComponentDelegate" class="idl-interface">ComponentDelegate</a> interface.
        </p>
<p class="todo">
          Specify better the interaction with inheritance.
        </p>
<p>
            The <a href="#idl-ComponentDelegate-did_render" class="idl-method">did_render</a> method is called right after a Bender component
            has been rendered.
          </p>
<p>
            The <a href="#idl-ComponentDelegate-set" class="idl-method">set</a> method is called when the <a class="attr" href="#delegate">delegate</a> is first set on a component.
            This lets the delegate perform any sort of initialization that is
            necessary before the component makes any further call.
          </p>
<p>
            The <a href="#idl-ComponentDelegate-unset" class="idl-method">unset</a> method is called when the <a class="attr" href="#delegate">delegate</a> is unset from the component.
            This lets the delegate perform any sort uninitialization that is
            necessary once the component will stop making any further call.
          </p>
<p>
            The <a href="#idl-ComponentDelegate-will_render" class="idl-method">will_render</a> method is called right before a Bender
            component will been rendered.
          </p></section></section></section><section id="content"><h3>6.3 The <code>content</code> element</h3>
<p class="desc">Provide a location for custom rendering for derived
        components.</p>
<section class="spec"><p>Child of:<ul>
<li><a href="#foreign-view-content"><em>foreign view content</em></a></li>
<li><a href="#view">view</a></li>
</ul></p>
<p>Content:<ul><li>mixed content:<ul>
<li>zero or more <a href="#component">component</a> elements</li>
<li>zero or more <a href="#foreign-view-content"><em>foreign view content</em></a> elements</li>
<li>zero or more <a href="#text">text</a> elements</li>
</ul>
</li></ul></p></section><section class="longdesc">
        <p>
          A component may extend the view of its prototype by having its own
          <a class="elem" href="#view">view</a> element.
          A view can be extended if and only if it has a descendant <a class="elem" href="#content">content</a> element.
          The purpose of this element is two-fold:
        </p>
        <ol>
          <li>
            indicate the <strong>location</strong> of the extension.
            The derived component’s <a class="elem" href="#view">view</a> will be rendered
            in place of this element;
          </li>
          <li>
            provide <strong>default content</strong> when there is no
            derived component, or the derived component has no child <a class="elem" href="#view">view</a> element.
            The children of the element, if any, are rendered following the same
            rules as the contents of the <a class="elem" href="#view">view</a> element in the
            absence of extended content.
          </li>
        </ol>
        <p>
          A view with no descendant <a class="elem" href="#content">content</a> element cannot be
          extended, even if derived components have their own child <a class="elem" href="#view">view</a> element.
        </p>
        <p>
          Although this is not specified in the schema, a <a class="elem" href="#view">view</a>
          element may have at most <a class="elem" href="#content">content</a> descendant.
        </p>
      </section></section><section id="foreign-view-content"><h3>6.4 Foreign view content</h3>
<p class="desc">Foreign content appearing in the view of a component.</p>
<section class="spec"><p>Child of:<ul>
<li><a href="#content">content</a></li>
<li><a href="#foreign-view-content"><em>foreign view content</em></a></li>
<li><a href="#view">view</a></li>
</ul></p>
<p>Content:<ul>
<li>zero or more <em>free</em> attributes</li>
<li>mixed content:<ul>
<li>zero or more <a href="#attribute">attribute</a> elements</li>
<li>zero or more <a href="#component">component</a> elements</li>
<li>optional 
            <a href="#content">content</a> element
          </li>
<li>zero or more <a href="#foreign-view-content"><em>foreign view content</em></a> elements</li>
<li>zero or more <a href="#text">text</a> elements</li>
</ul>
</li>
</ul></p></section><section class="longdesc">
        <section id="idp626016"><h3>6.4.1 Role of foreign content</h3>
<p>
            The view of a component may contain arbitrary markup.
            This markup is not interpreted by Bender and is passed <em>as
              is</em> to the runtime when the component is rendered.
            For instance, it is possible to use HTML, SVG and MathML to render
            Bender components in a HTML5 runtime; but Bender does not need to
            be aware of any of these markup languages and will just pass that
            content along.
          </p>
<p>
            Foreign elements in a view have the same content model as the
            <a class="elem" href="#view">view</a> element, and may also have an <a class="attr" href="#id">id</a> attribute and any attribute that is not in the Bender
            namespace.
            A foreign element may have other foreign elements, Bender
            <a class="elem" href="#component">component</a> elements or text content as children.
            It is possible to have a Bender <a class="elem" href="#content">content</a> element
            as a child, as long as the view as a whole has only one such
            descendant element.
          </p></section>
        <section id="idp630976"><h3>6.4.2 Rendering of foreign content</h3>
<p>
            A foreign element is rendered by creating a new element with the
            same qualified name in the target document.
            All of its attribute except for <a class="attr" href="#id">id</a> are copied to
            the new element with the same value.
            The <a class="attr" href="#id">id</a> attribute is used by the component watches
            to identify this element through the <a class="attr" href="#view"></a>
            attribute.
          </p>
<p>
            Then, the contents of the element are rendered.
            Element children are rendered following their rendering rules.
            Text child nodes are copied to the new element (<em>i.e.</em>,
            new text child nodes are created in the target document.)
          </p></section>
      </section></section><section id="get"><h3>6.5 The <code>get</code> element</h3>
<p class="desc">Event or property being watched.</p>
<section class="spec"><p>Child of:<ul><li><a href="#watch">watch</a></li></ul></p>
<p>Content:<ul>
<li>choice of:<ul>
<li>group of:<ul>
<li>
<a href="#event">event</a> attribute</li>
<li>optional 
        <a href="#component-ref">component</a> attribute
      </li>
</ul>
</li>
<li>group of:<ul>
<li>
<a href="#dom-event">dom-event</a> attribute</li>
<li>optional 
        <a href="#view-ref">view</a> attribute
      </li>
</ul>
</li>
<li>group of:<ul>
<li>
<a href="#property-ref">property</a> attribute</li>
<li>optional 
        <a href="#component-ref">component</a> attribute
      </li>
</ul>
</li>
</ul>
</li>
<li>optional 
          choice of:<ul>
<li>
<a href="#value">value</a> attribute</li>
<li><em>text</em></li>
</ul>
        </li>
</ul></p></section><section class="longdesc">
        <section id="idp643328"><h4>6.5.1 Watch inputs</h4>
<p>
            A <a class="elem" href="#get">get</a> element describe an <strong>input</strong> of a
            <a class="elem" href="#watch">watch</a>.
            An input can be <strong>activated</strong> once its
            <em>activation criteria</em> are met, as described in the
            following sections.
            Once an input is actived, the corresponding
            <strong>outputs</strong> (<em>i.e.</em>, <a class="elem" href="#set">set</a> child elements) of the parent watch are applied.
            An active input stays active, and cannot be activated anymore, until
            the end of a dataflow cycle, at which point all active inputs become
            inactive.
          </p></section>
        <section id="idp648288"><h4>6.5.2 Bender events</h4></section>
        <section id="idp649072"><h4>6.5.3 DOM events</h4></section>
        <section id="idp649856"><h4>6.5.4 Properties</h4></section>
      </section></section><section id="link"><h3>6.6 The <code>link</code> element</h3>
<p class="desc">Associate external resources with the component.</p>
<section class="spec"><p>Child of:<ul><li><a href="#component">component</a></li></ul></p>
<p>Content:<ul>
<li>
<a href="#rel">rel</a> attribute</li>
<li>
<a href="#href-link">href</a> attribute</li>
</ul></p></section><section class="longdesc">
        <p>This element is similar to the <a href="http://www.w3.org/html/wg/drafts/html/master/document-metadata.html#the-link-element">HTML link element</a>.
          It allows to link the component to other resources, namely stylesheets
          and scripts.</p>
        <p>The destination of the link is given by the <a class="attr" href="#href-link">href</a> attribute, which must be present and must contain
          a valid non-empty URL potentially surrounded by spaces.</p>
        <p>The type of link is indicated by the <a class="attr" href="#rel">rel</a>
          attribute, which must be present and must contain a valid keyword
          potentially surrounded by spaces. The valid keywords and their
          signification are:</p>
        <ul>
          <li>
<span class="keyword">script</span>: import a script. The URL must
            point to a Javascript file.</li>
          <li>
<span class="keyword">stylesheet</span>: import a stylesheet. The URL
            must point to a CSS file. Handling of stylesheet is dependent on the
            runtime: in the case of HTML output, a new <code>link</code>
            element is created in the <code>head</code> of the document; in
            the case of SVG, a new <code>link</code> element is created in
            the <code>svg</code> element of the document (using the correct
            <code>xlink:href</code> attribute.)</li>
        </ul>
        <p>The context manages the linked resources for all components and
          loads resources only once.</p>
      </section></section><section id="property"><h3>6.7 The <code>property</code> element</h3>
<p class="desc">Define a property of the component.</p>
<section class="spec"><p>Child of:<ul><li><a href="#component">component</a></li></ul></p>
<p>Content:<ul>
<li>
<a href="#property-name">name</a> attribute</li>
<li>optional 
          <a href="#as">as</a> attribute
        </li>
<li>optional 
          <a href="#value">value</a> attribute
        </li>
<li>optional 
          <em>text</em>
        </li>
</ul></p></section><section class="longdesc">
        <p>
          A property is a named Javascript value associated with a component.
          A property allows a component to maintain its state.
          Properties can be <strong>watched</strong> and
          <strong>bound</strong>.
        </p>
        <p>
          The <strong>name</strong> of the property is given by the <a class="attr" href="#property-name">name</a> attribute, which must be present and must
          contain a non-empty string of characters potentially surrounded by
          spaces.
          The name of the property is obtained by trimming leading and trailing
          whitespace from the <a class="attr" href="#property-name">name</a> attribute.
          No other normalization is performed on the name of a property.
          One consequence is that property names are case-sensitive, as they are
          in Javascript.
          A property name must be unique within a component; <em>i.e.</em>,
          a <a class="elem" href="#component">component</a> element cannot have two or more child
          <a class="elem" href="#property">property</a> elements with the same <a class="attr" href="#property-name">name</a> attribute (after whitespace has been
          trimmed.)
        </p>
        <p>
          The <strong>value</strong> of the property is given by the <a class="attr" href="#value">value</a> attribute.
          Because an XML attribute can only contain a string, authors may also
          specify how that string should be interpreted with the <a class="attr" href="#as">as</a> attribute.
        </p>
      </section></section><section id="set"><h3>6.8 The <code>set</code> element</h3>
<p class="desc">Action associated with a watch.</p>
<section class="spec"><p>Child of:<ul><li><a href="#watch">watch</a></li></ul></p>
<p>Content:<ul>
<li>choice of:<ul>
<li>group of:<ul>
<li>
<a href="#attr">attr</a> attribute</li>
<li>optional 
        <a href="#view-ref">view</a> attribute
      </li>
</ul>
</li>
<li>group of:<ul>
<li>
<a href="#event">event</a> attribute</li>
<li>optional 
        <a href="#component-ref">component</a> attribute
      </li>
</ul>
</li>
<li>group of:<ul>
<li>
<a href="#property-ref">property</a> attribute</li>
<li>optional 
        <a href="#component-ref">component</a> attribute
      </li>
</ul>
</li>
</ul>
</li>
<li>optional 
          choice of:<ul>
<li>
<a href="#value">value</a> attribute</li>
<li><em>text</em></li>
</ul>
        </li>
</ul></p></section></section><section id="text"><h3>6.9 The <code>text</code> element</h3>
<p class="desc">Output a text node on rendering.</p>
<section class="spec"><p>Child of:<ul>
<li><a href="#content">content</a></li>
<li><a href="#foreign-view-content"><em>foreign view content</em></a></li>
<li><a href="#view">view</a></li>
</ul></p>
<p>Content:<ul>
<li>optional 
          <a href="#id">id</a> attribute
        </li>
<li>choice of:<ul>
<li>
<a href="#value">value</a> attribute</li>
<li><em>text</em></li>
</ul>
</li>
</ul></p></section><section class="longdesc">
        <p>
          The purpose of the <a class="elem" href="#text">text</a> element, similarly to the <a class="elem" href="#attribute">attribute</a> element, is twofold.
          First, it provides a way to add text child nodes to rendered elements
          explicitly.
          Second, by giving an <a class="attr" href="#id">id</a> attribute to the <a class="elem" href="#text">text</a>
          element, it can become the target of a <a class="elem" href="#set">set</a> element.
        </p>
        <p>
          An <a class="elem" href="#text">text</a> element must have either a <a class="attr" href="#attribute-name">name</a> attribute or (possibly empty) text content.
          This is the value for the rendered attribute.
        </p>
        <p>
          When the parent element is rendered, a new text node is added in place
          of this element.
          The content of the new text node is the same as the value of the
          element.
        </p>
      <section><p><em>Javascript API</em></p>
<pre class="api">Interface <span class="idl-interface-def" id="interface-"></span> {
  attribute string <span class="idl-attribute-def" id="idl-attribute-value">value</span>;
  Node <span class="idl-method-def" id="idl--insertBefore">insertBefore</span>(Node child);
  void <span class="idl-method-def" id="idl--set_text_content">set_text_content</span>(string text);
}</pre>
<p>
            The <a href="#idl-attribute-value" class="idl-attribute">value</a> property of a <a href="#interface-" class="idl-interface"></a> reflects
            the value of the <a class="attr" href="#value">value</a> attribute of the element, or
            its text content, whichever is set.
            Getting the value of this property returns the value of the <a class="attr" href="#value">value</a> attribute if it is defined, or the text content of
            the element otherwise.
            Setting the value always sets the <a class="attr" href="#value">value</a> attribute
            and clears the text content of the element, if any.
            When setting a new value, all rendered instances of the parent
            component and components that derive from it are updated.
          </p>
<p>
            As <a class="elem" href="#text">text</a> can only have text content, <a href="#idl--insertBefore" class="idl-method">insertBefore</a> will only
            insert a text or CDATA node.
            When a new child node is inserted, the <a class="attr" href="#value">value</a>
            attribute is removed the <a class="elem" href="#text">text</a> element.
            All rendered instances of the parent component and components that
            derive from it are updated.
          </p>
<p>
            <a href="#idl--set_text_content" class="idl-method">set_text_content</a> updates the text content of the <a class="elem" href="#text">text</a> element.
            When updating the text content, the <a class="attr" href="#value">value</a> attribute
            is removed from the <a class="elem" href="#text">text</a> element.
            All rendered instances of the parent component and components that
            derive from it are updated.
          </p></section></section></section><section id="view"><h3>6.10 The <code>view</code> element</h3>
<p class="desc">Describe the rendering of a component.</p>
<section class="spec"><p>Child of:<ul><li><a href="#component">component</a></li></ul></p>
<p>Content:<ul><li>mixed content:<ul>
<li>zero or more <a href="#component">component</a> elements</li>
<li>optional 
            <a href="#content">content</a> element
          </li>
<li>zero or more <a href="#foreign-view-content"><em>foreign view content</em></a> elements</li>
<li>zero or more <a href="#text">text</a> elements</li>
</ul>
</li></ul></p></section></section><section id="watch"><h3>6.11 The <code>watch</code> element</h3>
<p class="desc">Define a watch for the component.</p>
<section class="spec"><p>Child of:<ul><li><a href="#component">component</a></li></ul></p>
<p>Content:<ul><li>interleaving of:<ul>
<li>one or more <a href="#get">get</a> elements</li>
<li>zero or more <a href="#set">set</a> elements</li>
</ul>
</li></ul></p></section><section class="longdesc">
        <p>
          The <a class="elem" href="#watch">watch</a> element defines a <strong>watch</strong> for the
          component.
          A watch has <em>inputs</em>, described by <a class="elem" href="#get">get</a>
          elements, and <em>outputs</em>, described by <a class="elem" href="#set">set</a>
          elements.
          Once an input of the watch is active, all of its outputs are applied
          in document order.
        </p>
        <p>
          When a child <a class="elem" href="#get">get</a> or <a class="elem" href="#set">set</a> element is
          added or removed, the rendering of the component and of the components
          that derive from it is updated.
        </p>
      <section><p><em>Javascript API</em></p>
<pre class="api">Interface <span class="idl-interface-def" id="interface-BenderWatchElement">BenderWatchElement</span> : <a href="#interface-BenderElement">BenderElement</a> {
  readonly attribute BenderGetElement[] <span class="idl-attribute-def" id="idl-attribute-gets">gets</span>;
  readonly attribute BenderSetElement[] <span class="idl-attribute-def" id="idl-attribute-sets">sets</span>;
}</pre>
<p>
            <a href="#idl-attribute-gets" class="idl-attribute">gets</a> is the list of the <a class="elem" href="#get">get</a>
            child elements in document order.
          </p>
<p>
            <a href="#idl-attribute-sets" class="idl-attribute">sets</a> is the list of the <a class="elem" href="#set">set</a>
            child elements in document order.
          </p></section></section></section></section><section id="idp724416"><h2>7 Attributes</h2>
<section id="as"><h3>7.1 The <code>as</code> attribute</h3>
<p class="desc">How to parse a property value.</p>
<section class="spec"><p>Attribute of:<ul><li><a href="#property">property</a></li></ul></p>
<p>Content:<ul>choice of:<ul>
<li>value <span class="keyword">boolean</span>
</li>
<li>value <span class="keyword">dynamic</span>
</li>
<li>value <span class="keyword">number</span>
</li>
<li>value <span class="keyword">string</span>
</li>
</ul>
</ul></p></section><section class="longdesc">
        <p>

        </p>
      </section></section><section id="attr"><h3>7.2 The <code>attr</code> attribute</h3>
<p class="desc">Attribute of a view element to be set.</p>
<section class="spec"><p>Attribute of:<ul><li><a href="#set">set</a></li></ul></p>
<p>Content:<ul>data of type <span class="data-type">Name</span>
</ul></p></section></section><section id="component-ref"><h3>7.3 The <code>component</code> attribute</h3>
<p class="desc">Reference to a component.</p>
<section class="spec"><p>Attribute of:<ul>
<li><a href="#get">get</a></li>
<li><a href="#set">set</a></li>
</ul></p>
<p>Content:<ul>data of type <span class="data-type">token</span>
</ul></p></section></section><section id="delegate"><h3>7.4 The <code>delegate</code> attribute</h3>
<p class="desc">Delegate object for a component.</p>
<section class="spec"><p>Attribute of:<ul><li><a href="#component">component</a></li></ul></p>
<p>Content:<ul><li>any string</li></ul></p></section></section><section id="dom-event"><h3>7.5 The <code>dom-event</code> attribute</h3>
<p class="desc">DOM event to watch.</p>
<section class="spec"><p>Attribute of:<ul><li><a href="#get">get</a></li></ul></p>
<p>Content:<ul><li>any string</li></ul></p></section></section><section id="event"><h3>7.6 The <code>event</code> attribute</h3>
<p class="desc">Bender event to watch or to notify.</p>
<section class="spec"><p>Attribute of:<ul>
<li><a href="#get">get</a></li>
<li><a href="#set">set</a></li>
</ul></p>
<p>Content:<ul><li>any string</li></ul></p></section></section><section id="href-component"><h3>7.7 The <code>href</code> attribute</h3>
<p class="desc">URI of the prototype component.</p>
<section class="spec"><p>Attribute of:<ul><li><a href="#component">component</a></li></ul></p>
<p>Content:<ul>data of type <span class="data-type">anyURI</span>
</ul></p></section></section><section id="href-link"><h3>7.8 The <code>href</code> attribute</h3>
<p class="desc">URI of a linked resource.</p>
<section class="spec"><p>Attribute of:<ul><li><a href="#link">link</a></li></ul></p>
<p>Content:<ul>data of type <span class="data-type">anyURI</span>
</ul></p></section></section><section id="id"><h3>7.9 The <code>id</code> attribute</h3>
<p class="desc">Unique identifier for an element.</p>
<section class="spec"><p>Attribute of:<ul>
<li><a href="#attribute">attribute</a></li>
<li><a href="#component">component</a></li>
<li><a href="#text">text</a></li>
</ul></p>
<p>Content:<ul>data of type <span class="data-type">ID</span>
</ul></p></section></section><section id="attribute-name"><h3>7.10 The <code>name</code> attribute</h3>
<p class="desc">Name of an attribute.</p>
<section class="spec"><p>Attribute of:<ul><li><a href="#attribute">attribute</a></li></ul></p>
<p>Content:<ul>data of type <span class="data-type">Name</span>
</ul></p></section></section><section id="property-name"><h3>7.11 The <code>name</code> attribute</h3>
<p class="desc">Name of a property.</p>
<section class="spec"><p>Attribute of:<ul><li><a href="#property">property</a></li></ul></p>
<p>Content:<ul><li>any string</li></ul></p></section></section><section id="ns"><h3>7.12 The <code>ns</code> attribute</h3>
<p class="desc">Namespace URI of an attribute.</p>
<section class="spec"><p>Attribute of:<ul><li><a href="#attribute">attribute</a></li></ul></p>
<p>Content:<ul><li>any string</li></ul></p></section></section><section id="property-ref"><h3>7.13 The <code>property</code> attribute</h3>
<p class="desc">Reference a component’s property.</p>
<section class="spec"><p>Attribute of:<ul>
<li><a href="#get">get</a></li>
<li><a href="#set">set</a></li>
</ul></p>
<p>Content:<ul>data of type <span class="data-type">Name</span>
</ul></p></section></section><section id="rel"><h3>7.14 The <code>rel</code> attribute</h3>
<p class="desc">Relationship of the linked resource with the component.</p>
<section class="spec"><p>Attribute of:<ul><li><a href="#link">link</a></li></ul></p>
<p>Content:<ul>choice of:<ul>
<li>value <span class="keyword">script</span>
</li>
<li>value <span class="keyword">stylesheet</span>
</li>
</ul>
</ul></p></section></section><section id="view-ref"><h3>7.15 The <code>view</code> attribute</h3>
<p class="desc">Reference an element in the view of the component.</p>
<section class="spec"><p>Attribute of:<ul>
<li><a href="#get">get</a></li>
<li><a href="#set">set</a></li>
</ul></p>
<p>Content:<ul>data of type <span class="data-type">token</span>
</ul></p></section></section><section id="value"><h3>7.16 The <code>value</code> attribute</h3>
<p class="desc">Set a value.</p>
<section class="spec"><p>Attribute of:<ul>
<li><a href="#attribute">attribute</a></li>
<li><a href="#get">get</a></li>
<li><a href="#property">property</a></li>
<li><a href="#set">set</a></li>
<li><a href="#text">text</a></li>
</ul></p>
<p>Content:<ul><li>any string</li></ul></p></section></section></section>
</div></div>
</div>
<script src="../../flexo.js"></script><script src="../../bender.js"></script><script>

"use strict";

var context = bender.create_context();
context.$("component", { href: "../../demo/logo.xml", sides: "7", fgcolor: "#db7093",
  bgcolor: "white" }).create_instance(document.querySelector("#logo a"));

    </script>
</body>
</html>
